
 红黑树
<!-- TOC -->

- [性质](#性质)
- [复杂度](#复杂度)
- [插入](#插入)

<!-- /TOC -->

# 性质
 1、节点是红色或者是黑色；
 2、根节点是黑色；
 3、每个叶节点（NIL或空节点）是黑色；
 4、每个红色节点的两个子节点都是黑色的（也就是说不存在两个连续的红色节点）
 5、从任一节点到其没个叶节点的所有路径都包含相同数目的黑色节点；

![红黑树](https://images0.cnblogs.com/i/497634/201403/251730074203156.jpg)

# 复杂度

红黑树的时间复杂度为: O(lgn)

下面通过“数学归纳法”对红黑树的时间复杂度进行证明。

定理：一棵含有n个节点的红黑树的高度至多为2log(n+1).

证明：
    "一棵含有n个节点的红黑树的高度至多为2log(n+1)" 的逆否命题是 "高度为h的红黑树，它的包含的内节点个数至少为 2^h/2^-1个"。
    我们只需要证明逆否命题，即可证明原命题为真；即只需证明**高度为h的红黑树，它的包含的内节点个数至少为 2^h/2^-1个**。
    从某个节点x出发（不包括该节点）到达一个叶节点的任意一条路径上，黑色节点的个数称为该节点的黑高度(x's black height)，记为bh(x)。关于bh(x)有两点需要说明：
    1. 第1点：根据红黑树的"特性(5) ，即从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点"可知，从节点x出发到达的所有的叶节点具有相同数目的黑节点。这也就意味着，bh(x)的值是唯一的！
    2. 第2点：根据红黑色的"特性(4)，即如果一个节点是红色的，则它的子节点必须是黑色的"可知，从节点x出发达到叶节点"所经历的黑节点数目">= "所经历的红节点的数目"。假设x是根节点，则可以得出结论"bh(x) >= h/2"。进而，我们只需证明 "高度为h的红黑树，它的包含的黑节点个数至少为 2^bh(x)^-1个"即可。

到这里，我们将需要证明的定理已经由
**一棵含有n个节点的红黑树的高度至多为2log(n+1)**
转变成只需要证明
**高度为h的红黑树，它的包含的内节点个数至少为 2^bh(x)^-1个**。


下面通过"数学归纳法"开始论证高度为h的红黑树，它的包含的内节点个数至少为 2^bh(x)^-1个"。

(01) 当树的高度h=0时，
    内节点个数是0，bh(x) 为0，2^bh(x)^-1 也为 0。显然，原命题成立。

(02) 当h>0，且树的高度为 h-1 时，它包含的节点个数至少为 2^bh(x)-1^-1。这个是根据(01)推断出来的！

下面，由树的高度为 h-1 的已知条件推出“树的高度为 h 时，它所包含的节点树为 2^bh(x)^-1。
当树的高度为 h 时，
    对于节点x(x为根节点)，其黑高度为bh(x)。
    对于节点x的左右子树，它们黑高度为 bh(x) 或者 bh(x)-1。
    根据(02)的已知条件，我们已知 "x的左右子树，即高度为 h-1 的节点，它包含的节点至少为 2^bh(x)-1^-1 个"；

所以，节点x所包含的节点至少为 (2^bh(x)-1^-1) + (2^bh(x)-1^-1) + 1 = 2^bh(x)^-1。即节点x所包含的节点至少为 2^bh(x)^-1。
    因此，原命题成立。

由(01)、(02)得出，"高度为h的红黑树，它的包含的内节点个数至少为 2^bh(x)^-1个"。
    因此，“一棵含有n个节点的红黑树的高度至多为2log(n+1)”。

 ```
 class TreeNode<K,V> {
     TreeNode<K,V> parent;
     TreeNode<K,V> left;
     TreeNode<K,V> right;
     TreeNode<K,V> prev;
     boolean red;
 }
 ```

# 插入

 将一个节点插入到红黑树中，需要执行哪些步骤呢？首先，将红黑树当作一颗二叉查找树，将节点插入；然后，将节点着色为红色；最后，通过旋转和重新着色等方法来修正该树，使之重新成为一颗红黑树。

1.将插入的节点着色为红色，不会违背"特性(5)"！少违背一条特性，就意味着我们需要处理的情况越少。接下来，就要努力的让这棵树满足其它性质即可；满足了的话，它就又是一颗红黑树了

 2.对于"特性4"，是有可能违背的！

**新插入的结点是红色！**

1. 如果插入的是根结点，由于原树是空树，此情况只会违反性质2，因此直接把此结点涂为黑色；
2. 如果插入的结点的父结点是黑色，由于此不会违反性质2和性质4，红黑树没有被破坏，所以此时什么也不做。
3. 如果当前结点的父结点是红色且祖父结点的另一个子结点（叔叔结点）是红色；
* **解决：将当前节点的父节点和叔叔节点涂黑，祖父结点涂红，把当前结点指向祖父节点，从新的当前节点重新开始算法。**
4. 当前节点的父节点是红色,叔叔节点是黑色，当前节点是其父节点的左孩子(以左孩子为例)
* **解决：父节点变为黑色，祖父节点变为红色，在祖父节点为支点右旋。**
5. 当前节点的父节点是红色,叔叔节点是黑色，当前节点是其父节点的右子(以左孩子为例)
* **解决：当前节点的父节点做为新的当前节点，以新当前节点为支点左旋。问题转为4**


                A黑
            B红       nil
        D红     nil
    nil     nil